{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 238,
   "id": "97a543a2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Your fastq file was filtered!\n"
     ]
    }
   ],
   "source": [
    "import os # for using os.path.isfile() and os.remove() functions\n",
    "\n",
    "\n",
    "def main(input_fastq, output_file_prefix, save_filtered = False, \n",
    "         gc_bounds = (0,100), length_bounds = (0, 2**32), quality_threshold = 0):\n",
    "    '''Function main() deals with .fastq files. It opens .fastq, can calculates Q-score, GC-content, and length \n",
    "    for every read in file. According to values of _bound variables for each test, it filters reads and creates \n",
    "    '_passed.fastq' file with passed reads. If you also need '_failed.fastq' file with failed reads, you need to\n",
    "    pass to 'save_filtered' boolean True.\n",
    "    \n",
    "    Parameters:\n",
    "    input_fastq (str): path to .fastq file\n",
    "    output_file_prefix (str): first part of the output file(s) name(s)\n",
    "    save_filtered (bool): variable for decision about failed reads (True for saving them into '_failed.fastq' \n",
    "        file or not). Default is boolean False\n",
    "    gc_bounds (int, float, tuple, list): threshold(s) for read GC-content test. Default is (0, 100), single \n",
    "        int or float in gc_bounds is accepted as max boundary.\n",
    "    length_bounds (int, tuple, list): threshold(s) for read length test. Default is (0, 2**32), single int\n",
    "        in length_bounds is accepted as max boundary.\n",
    "        Attention! length_bounds can't be float!\n",
    "    quality_threshold (int): threshold for read quality test. Default is 0\n",
    "    \n",
    "    Returns: None\n",
    "    '''  \n",
    "    # removing output files with prefix if they are pre-existed\n",
    "    # for multimple function usage on the same input .fastq  \n",
    "    if os.path.isfile(output_file_prefix + '_passed.fastq'):\n",
    "        os.remove(output_file_prefix + '_passed.fastq')\n",
    "    if os.path.isfile(output_file_prefix + '_failed.fastq'):\n",
    "        os.remove(output_file_prefix + '_failed.fastq')\n",
    "    \n",
    "    with open(input_fastq) as row_data:\n",
    "        while True:\n",
    "            seq_read = get_read(row_data)\n",
    "            if seq_read[0] == '':\n",
    "                break\n",
    "            name, sequence, description, ascii_code = seq_read # naming of seq_read (list) elements\n",
    "            q_test = qscore_filter(ascii_code, quality_threshold) # variable for qscore_filter() return\n",
    "            gc_test = gc_content_filter(sequence, gc_bounds) # variable for gc_content_filter() return\n",
    "            length_test = length_filter(sequence, length_bounds) # variable for length_filter() return\n",
    "            output_generator(seq_read, q_test, gc_test, length_test, # calling function for output .fastq generation\n",
    "                             output_file_prefix, save_filtered)\n",
    "print(\"Your fastq file was filtered!\")\n",
    "\n",
    "\n",
    "def output_generator(seq_read, q_test, gc_test, length_test, \n",
    "                     output_file_prefix, save_filtered):\n",
    "    '''Function output_generator() generates one or two files with reads from input .fastq file after their \n",
    "    filtering. It creates you '_passed.fastq' with passed reads. If you choosed \"True\" for save_filtered \n",
    "    variable, it will also generates '_failed.fastq' file with failed reads.\n",
    "        \n",
    "    Parameters:\n",
    "    seq_read (list): all information about one read\n",
    "    q_test (bool): qscore_filter function return (True for passed read)\n",
    "    gc_test (bool): gc_content_filter function return (True for passed read)\n",
    "    length_test (bool): length_filter function return (True for passed read)\n",
    "    output_file_prefix (str): first part of the output file(s) name(s)\n",
    "    save_filtered (bool): variable for decision about failed reads (True for saving them into '_failed.fastq' \n",
    "        file or not)\n",
    "    \n",
    "    Returns: None\n",
    "    '''\n",
    "    \n",
    "    # appending reads into output .fastq\n",
    "    if False in (q_test, gc_test, length_test):\n",
    "        # appending reads into _failed.fastq file, variable save_filtered = True\n",
    "        if save_filtered:\n",
    "            with open(output_file_prefix+'_failed.fastq', 'a') as failed_reads:\n",
    "                for i in seq_read:\n",
    "                    failed_reads.write(i+'\\n')\n",
    "    else:\n",
    "        with open(output_file_prefix+'_passed.fastq', 'a') as passed_reads:\n",
    "                for i in seq_read:\n",
    "                    passed_reads.write(i+'\\n')\n",
    "\n",
    "                    \n",
    "def qscore_filter(ascii_code, quality_threshold):\n",
    "    '''This function calculates Q-score for every read in input .fastq file. \n",
    "    It decodes each nucleotide quality given in ASCII format into numeric Phred33 format and determines mean \n",
    "    value for read. After calculations function checks, whether read quality meets quality threshold. \n",
    "    \n",
    "    Parameters:\n",
    "    ascii_code (list): characters in ASCII format given in 4th string for every read\n",
    "    quality_threshold (int): threshold for read quality test (equals to 0 by default)\n",
    "    \n",
    "    Returns: bools after read quality checkout \n",
    "    True - if read passed checkout (read quality >= quality_threshold)\n",
    "    '''\n",
    "    \n",
    "    all_q_scores = 0\n",
    "    # cycle for nucleotide quality decoding in Phred33\n",
    "    for i in ascii_code:\n",
    "        q_score = ord(i) - 33\n",
    "        all_q_scores += q_score\n",
    "    read_quality = all_q_scores / len(ascii_code) # mean read quality calculation\n",
    "    \n",
    "    # mean read quality test using variable quality_threshold\n",
    "    if read_quality >= quality_threshold:\n",
    "        return True\n",
    "    else:\n",
    "        return False\n",
    "\n",
    "    \n",
    "def gc_content_filter(sequence, gc_bounds):\n",
    "    '''This function calculates percentage of GC nucleotides for every read in input .fastq file.\n",
    "    After calculations function checks, whether GC-content meets gc_bounds.  \n",
    "    \n",
    "    Parameters:\n",
    "    sequence (str): nucleic acid sequence given in 2nd string for every read\n",
    "    gc_bounds (int, float, tuple, list): threshold(s) for read GC-content test (equals to (0, 100) by default), single \n",
    "        int or float in gc_bounds is accepted as max boundary. \n",
    "    \n",
    "    Returns: bools after read GC-content checkout\n",
    "    True - if read passed checkout (read GC-percentage lies in gc_bounds)  \n",
    "    '''\n",
    "    # type determination of gc_bounds variable\n",
    "    # and setting up GC-content test thresholds\n",
    "    if type(gc_bounds) in (int, float):\n",
    "        min_gc = 0\n",
    "        max_gc = gc_bounds\n",
    "    else:\n",
    "        min_gc, max_gc = gc_bounds\n",
    "    \n",
    "    g_number = sequence.count('G') # counting G in read\n",
    "    c_number = sequence.count('C') # counting C in read\n",
    "    gc_content = (g_number + c_number) / len(sequence) * 100 # GC-content calculation\n",
    "    \n",
    "    # read GC-content test using thresholds based on gc_bounds variable\n",
    "    if min_gc <= gc_content <= max_gc: \n",
    "        return True\n",
    "    else:\n",
    "        return False\n",
    "\n",
    "    \n",
    "def length_filter(sequence, length_bounds):\n",
    "    '''This function calculates length for every read in input .fastq file.\n",
    "    After calculations function checks, whether read length meets length_bounds.\n",
    "    \n",
    "    Parameters:\n",
    "    sequence (str): nucleic acid sequence given in 2nd string for every read\n",
    "    length_bounds (int, tuple, list): threshold(s) for read length test (equals to (0, 2**32) by default), single int\n",
    "        in length_bounds is accepted as max boundary.\n",
    "    Attention! length_bounds can't be float!\n",
    "    \n",
    "    Returns: bools after read length checkout\n",
    "    True - if read passed checkout (read length lies in length_bound)  \n",
    "    '''\n",
    "    \n",
    "    # type determination of length_bounds variable\n",
    "    # and setting up length test thresholds \n",
    "    if type(length_bounds) is int:\n",
    "        min_length = 0\n",
    "        max_length = length_bounds\n",
    "    else:\n",
    "        min_length, max_length = length_bounds\n",
    "    \n",
    "    # read length test using thresholds based on length_bounds variable\n",
    "    if min_length <= len(sequence) <= max_length: \n",
    "        return True\n",
    "    else:\n",
    "        return False\n",
    "\n",
    "    \n",
    "def get_read(row_data):\n",
    "    '''This function gets one read (four strings) from input .fastq file and transforms it into list.\n",
    "    \n",
    "    Parameters:\n",
    "    row_data (opened input .fastq file): variable generated during input_fastq file opening\n",
    "    \n",
    "    Returns:\n",
    "    seq_read (list): all information about one read\n",
    "    '''\n",
    "    \n",
    "    # gitting list of read information (4 strings) \n",
    "    seq_read = [row_data.readline().strip() for i in range(4)]\n",
    "    return seq_read"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
